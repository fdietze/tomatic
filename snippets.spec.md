## **Technical Specification: Snippets and Advanced Chat Features**

### **1. Overview**

This document outlines the implementation of a new "Snippets" feature and several enhancements to the chat interface. The project is divided into seven main parts:

1.  **Core Snippet Feature**: Implementing basic CRUD (Create, Read, Update, Delete) functionality for text snippets.
2.  **Generated Snippets**: Extending snippets to have their content dynamically generated by a language model.
3.  **Database Migration**: Upgrading the application's database schema to support snippets.
4.  **Chat Integration**: Allowing users to reference snippets directly in the chat input using `@<snippetname>` syntax.
5.  **Data Integrity**: Ensuring that chat history and message regeneration use the most up-to-date snippet content.
6.  **Advanced Snippet Logic**: Implementing support for recursive snippet resolution and cycle detection.
7.  **Code Quality**: Adding logging and mandating comprehensive testing for all new features.

A core constraint of this project is that **no code should be shared between the new Snippets feature and the existing System Prompts feature**. This requires creating separate components, state management logic, and persistence functions for snippets to allow for independent future development.

### **2. Part 1: Core Snippet Feature (CRUD)**

This part covers the foundational functionality for managing snippets.

#### **2.1. Data Structure**

A new `Snippet` interface shall be defined in `src/types/storage.ts`:

```typescript
export interface Snippet {
  name: string;
  content: string;
  isGenerated: boolean; // Must be a required boolean
  prompt?: string;
  model?: string;
}
```

#### **2.2. Persistence Layer (IndexedDB)**

-   The database schema in `src/services/persistence.ts` will be updated.
-   The `DB_VERSION` constant must be incremented from `2` to `3`.
-   The `upgrade` logic must be modified to create a new object store named `snippets`.
-   The `snippets` store's key path will be the `name` property.

#### **2.3. State Management (`zustand`)**

The `appStore` in `src/store/appStore.ts` will be extended to manage snippets:

-   **State**: Add a new array to the `AppState` interface: `snippets: Snippet[]`.
-   **Actions**: Implement the following new asynchronous actions:
    -   `loadSnippets()`: Fetches all snippets from the `snippets` store in IndexedDB and updates the state.
    -   `addSnippet(snippet: Snippet)`: Saves a new snippet to IndexedDB and reloads the snippets in the state.
    -   `updateSnippet(oldName: string, snippet: Snippet)`: Updates an existing snippet. This requires deleting the old entry and adding the new one if the name has changed. Reloads the state.
    -   `deleteSnippet(name: string)`: Deletes a snippet from IndexedDB and reloads the state.

#### **2.4. User Interface (`SettingsPage.tsx`)**

-   A new section titled "Snippets" shall be added to the `SettingsPage`, located directly below the "System Prompts" section.
-   This section will contain a "New Snippet" button and a list of existing snippets.
-   A new React component, `SnippetItem.tsx`, will be created to render, edit, and manage a single snippet. This component's structure will be analogous to `SystemPromptItem.tsx` but will be a completely separate implementation.

#### **2.5. Snippet Name Validation**

-   Snippet names are restricted to **alphanumeric characters and underscores** (regex: `/[a-zA-Z0-9_]+/`).
-   Validation must be implemented in the `SnippetItem.tsx` component to provide immediate feedback to the user if the name is empty, contains invalid characters, or is a duplicate of an existing snippet name.

---

### **3. Part 2: Generated Snippets**

This part extends the snippet editor to support content generation via a language model.

#### **3.1. UI Layout and Behavior**

The `SnippetItem.tsx` component, when in edit mode, will have the following field order and behavior:

1.  **Name**: Standard text input.
2.  **"Generated Snippet"**: A checkbox.
3.  **Model**: A searchable `Combobox` component. This field is **only visible** when the "Generated Snippet" box is checked. It should be populated with the list of available models from the `appStore`.
4.  **Prompt**: A `textarea`. This field is **only visible** when the "Generated Snippet" box is checked.
5.  **Content**:
    -   If "Generated Snippet" is **unchecked**, this is a standard, editable `textarea`.
    -   If "Generated Snippet" is **checked**, this field becomes a **read-only view that renders its value as Markdown**, using the existing `Markdown` component.

#### **3.2. Automatic Content Generation**

-   When a snippet has `isGenerated: true`, its `content` will be updated automatically.
-   An API call to the language model will be triggered whenever the `prompt` or `model` fields are changed by the save button.
-   Another trigger for regeneration is, when the content of a referenced snippet changes (e.g. by generation) recursively.
-   The generation process is as follows:
    1.  The `prompt` text is sent as a user message to the selected `model`.
    2.  The content of the assistant's response becomes the new value for the snippet's `content` field.
    3.  The UI must provide a visual indicator (e.g., a loading spinner) while the content is being generated.

---

### **4. Part 3: Database Migration**

-   A new, dedicated end-to-end test file will be created to validate the database migration from v2 to v3.
-   **Test Strategy**:
    1.  Using Playwright's `addInitScript`, programmatically create an IndexedDB named `tomatic_chat_db` with the v2 schema *before* the application loads. Populate the `chat_sessions` and `system_prompts` stores with sample data.
    2.  Load the application, which will trigger the `upgrade` logic in `persistence.ts`.
    3.  The test will then connect to the database and assert that:
        -   The database version is now `3`.
        -   The new `snippets` object store exists.
        -   All pre-existing data in the `chat_sessions` and `system_prompts` stores remains intact.

---

### **5. Part 4: Chat Integration (`@<snippetname>`)**

This part integrates snippet functionality into the chat input.

#### **5.1. Snippet Replacement Logic**

-   The `submitMessage` action in `appStore.ts` must be modified.
-   Before a message is sent to the model, its content must be scanned for `@<snippetname>` patterns.
-   For each valid snippet name found, the pattern will be replaced with the content of that snippet.
-   **Important**: The user's input in the `textarea` must not visibly change. This replacement is purely for the data sent to the model.

#### **5.2. `Message` Data Structure Enhancement**

-   The `Message` interface in `src/types/chat.ts` must be modified to support storing both the user's original input and the processed text.
-   Add a new optional field: `raw_content?: string`.

-   When a user sends a message containing snippets:
    -   The `raw_content` field will store the user's original input (e.g., `"A message with @greet"`).
    -   The `content` field will store the processed text with snippets expanded (e.g., `"A message with Hello, world!"`).

#### **5.3. UI and Message Editing**

-   The `ChatMessage.tsx` component must be updated to render `raw_content` if it is present on a user message. Otherwise, it should render `content`.
-   When a user clicks the "edit" button on a message, the `textarea` must be populated with `raw_content` to allow them to edit the original text, including the `@<snippetname>` references.

#### **5.4. Error Handling**

-   If a user tries to submit a message containing a snippet name that does not exist (e.g., `@nonexistent`), the submission must be **blocked**.
-   An error message (e.g., "Snippet '@nonexistent' not found.") must be displayed in the chat interface UI.

---

### **6. Part 5: Data Integrity and Regeneration**

This section ensures that snippet content remains up-to-date during the chat lifecycle.

-   The `regenerateMessage` action in `appStore.ts` must be refactored.
-   Instead of re-sending the previous `content`, the logic must take the `raw_content` of the original user message and re-run the snippet expansion process.
-   This ensures that if a snippet was updated *after* the original message was sent, regenerating the response will use the **new, updated** snippet content.

---

### **7. Part 6: Advanced Snippet Logic (Recursion)**

This section adds support for nested snippets.

#### **7.1. Recursive Resolution**

-   The snippet replacement logic must support recursion. If a snippet's content contains a reference to another snippet (e.g., Snippet A: `This is @B`, Snippet B: `Hello!`), it must be fully resolved (e.g., `This is Hello!`).
-   There will be no maximum recursion depth.

#### **7.2. Cycle Detection**

-   The resolution algorithm **must** implement cycle detection.
-   If a circular reference is detected (e.g., A references B, and B references A), the resolution process must be aborted.
-   An error must be thrown and displayed to the user, indicating that a snippet cycle was detected.

---

### **8. Part 7: Code Quality and Testing**

#### **8.1. Logging**

-   Lightweight, informative logs shall be added to the message submission and regeneration flows.
-   These logs should detail the snippet resolution process, including which snippets were found and what the final processed content is. These logs should remain in the production codebase to aid future debugging.

#### **8.2. End-to-End Testing**

Comprehensive Playwright tests are required for all new user-facing functionality:

-   **CRUD Workflow**: A test to create, update, and delete a standard snippet.
-   **Generated Snippets**: A test to create a generated snippet and verify that its content is automatically updated when the prompt is changed.
-   **Chat Integration**: A test to send a message with a snippet and verify the model receives the expanded content.
-   **Error Handling**: Tests for submitting messages with non-existent snippets and for snippet name validation errors.
-   **Regeneration Flow**: A crucial test that follows this exact flow:
    1. Create a snippet.
    2. Send a message using the snippet.
    3. Navigate to settings and edit the snippet's content.
    4. Navigate back to the chat and regenerate the AI's response.
    5. Assert that the API request for the regeneration contains the **new, updated** snippet content.
-   **Recursion & Cycles**: A test that verifies successful recursive resolution and another that asserts an error is shown when a cycle is present.
-   **Database Migration**: The dedicated migration test described in Part 3.

- For generated snippets, the prompt can contain snippet references that are resolved recursively at generation time.
- saving a snippet should regenerate all generated snippets that depend on it recursively. (add a test for that)
